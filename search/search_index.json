{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ICD 11 Website Essentials I'm Kevin and I am a UCLA Student. This website is a quick, informal intro including documentation about my work on ICD 11. PRoduced under Creative Commons License. Contents Dash Numpy and Pandas basics Plotly basics Dash basics ICD 11 Dash Documentation Flask Introduction First webpage in Flask Dynamic routing in Flask","title":"Home"},{"location":"#icd-11-website-essentials","text":"I'm Kevin and I am a UCLA Student. This website is a quick, informal intro including documentation about my work on ICD 11. PRoduced under Creative Commons License.","title":"ICD 11 Website Essentials"},{"location":"#contents","text":"Dash Numpy and Pandas basics Plotly basics Dash basics ICD 11 Dash Documentation Flask Introduction First webpage in Flask Dynamic routing in Flask","title":"Contents"},{"location":"dash/NetworkX-learning/","text":"What is NetworkX NetworkX is a library in Python that specializes in working with network graphs. NetworkX comes with a set of functions that allow for populating, editing and exploring network graphs with node and edge attributes Network graphs Network graphs represent connections between data points called \"nodes\" and connections between these nodes called \"edges\". All nodes can have properties attached to them, and edges too have properties which specify the relationship between two nodes. In ICD 11, each node represents a disease/condition and has properties such as: - ID: Disease/Condition ID in ICD 11 - Title: Name of the node - Defn: Description of the node Creating Network Graphs Install NetworkX library pip install networkx Import library import networkx as nx Create empty graph G= nx.Graph() Add edges Adding edge between nodes automaticaly creates the nodes between which the edge is specified. You can also specify the properties of the edge. G.add_edge('A','B', <property 1> = <insert number or word>, ...) Add nodes with properties You can also add nodes and specify its properties: G.add_node('A', <property1> = <insert property>","title":"NetworkX basics"},{"location":"dash/NetworkX-learning/#what-is-networkx","text":"NetworkX is a library in Python that specializes in working with network graphs. NetworkX comes with a set of functions that allow for populating, editing and exploring network graphs with node and edge attributes","title":"What is NetworkX"},{"location":"dash/NetworkX-learning/#network-graphs","text":"Network graphs represent connections between data points called \"nodes\" and connections between these nodes called \"edges\". All nodes can have properties attached to them, and edges too have properties which specify the relationship between two nodes. In ICD 11, each node represents a disease/condition and has properties such as: - ID: Disease/Condition ID in ICD 11 - Title: Name of the node - Defn: Description of the node","title":"Network graphs"},{"location":"dash/NetworkX-learning/#creating-network-graphs","text":"","title":"Creating Network Graphs"},{"location":"dash/NetworkX-learning/#install-networkx-library","text":"pip install networkx","title":"Install NetworkX library"},{"location":"dash/NetworkX-learning/#import-library","text":"import networkx as nx","title":"Import library"},{"location":"dash/NetworkX-learning/#create-empty-graph","text":"G= nx.Graph()","title":"Create empty graph"},{"location":"dash/NetworkX-learning/#add-edges","text":"Adding edge between nodes automaticaly creates the nodes between which the edge is specified. You can also specify the properties of the edge. G.add_edge('A','B', <property 1> = <insert number or word>, ...)","title":"Add edges"},{"location":"dash/NetworkX-learning/#add-nodes-with-properties","text":"You can also add nodes and specify its properties: G.add_node('A', <property1> = <insert property>","title":"Add nodes with properties"},{"location":"dash/dash/","text":"Intro to Dash Dash is great because: - You can create dashboards in python - Served as web apps that you can deploy, not static html files - Composed of 2 parts: layout and interactivity like how moving sldier affects visualization Essential packages These packages must also be installed via pip install prior to loading them: import dash import dash_core_components as dcc import dash_html_components as html import plotly.graph_objs as go import numpy as np import pandas as pd Step 1: Create instance of Dash app = dash.Dash() app.layout = html.Div() Creates a division in our dashboard to insert things Sample barplot app.layout = html.Div(children = [ html.H1(\"Hello Dash!\"), html.Div(\"Dash: Web Dashboard with Python\"), dcc.Graph(id= \"example\", #dcc - dash core component and id for reference figure = {\"data\":[ #figure will take in dictionary {\"x\":[1,2,3],\"y\":[4,1,2],\"type\":\"bar\",\"name\":\"SF\"}, {\"x\":[1,2,3],\"y\":[2,4,5],\"type\":\"bar\",\"name\":\"NYC\"} ], \"layout\":{ #figure will have key for data and dictionary \"title\":\"BAR PLOTS!\" }}) #everything inside the div is a cjildren's list ]) if __name__ == '__main__': #checks if im running this script, it will grab application obj and run the server app.run_server() Documentation Breakdown After creating Dash app, we specify the layout of the Dashboard children - List of components in the Dashboard html.Div Creates a \"division\" on the webpage. This is needed because that \"division\" or block will contrain the Dash graphic, and we can create multiple Divisions for multiple Dashboards on the same webpage html.H1 - gives a header to the webpage html.Div - this nested Div creates another block within which is the Dashboard graphic dcc.Graph - specifies the type of graph that will be used. Depending on the graph, the data input will vary layout - Can specify the title of the plot. Arguments are listed in Plotly documentation We finally run the server using app.run_server . The server is required to keep running to access the webpage with the dashboard","title":"Dash Intro"},{"location":"dash/dash/#intro-to-dash","text":"Dash is great because: - You can create dashboards in python - Served as web apps that you can deploy, not static html files - Composed of 2 parts: layout and interactivity like how moving sldier affects visualization","title":"Intro to Dash"},{"location":"dash/dash/#essential-packages","text":"These packages must also be installed via pip install prior to loading them: import dash import dash_core_components as dcc import dash_html_components as html import plotly.graph_objs as go import numpy as np import pandas as pd","title":"Essential packages"},{"location":"dash/dash/#step-1-create-instance-of-dash","text":"app = dash.Dash() app.layout = html.Div() Creates a division in our dashboard to insert things","title":"Step 1: Create instance of Dash"},{"location":"dash/dash/#sample-barplot","text":"app.layout = html.Div(children = [ html.H1(\"Hello Dash!\"), html.Div(\"Dash: Web Dashboard with Python\"), dcc.Graph(id= \"example\", #dcc - dash core component and id for reference figure = {\"data\":[ #figure will take in dictionary {\"x\":[1,2,3],\"y\":[4,1,2],\"type\":\"bar\",\"name\":\"SF\"}, {\"x\":[1,2,3],\"y\":[2,4,5],\"type\":\"bar\",\"name\":\"NYC\"} ], \"layout\":{ #figure will have key for data and dictionary \"title\":\"BAR PLOTS!\" }}) #everything inside the div is a cjildren's list ]) if __name__ == '__main__': #checks if im running this script, it will grab application obj and run the server app.run_server() Documentation Breakdown After creating Dash app, we specify the layout of the Dashboard children - List of components in the Dashboard html.Div Creates a \"division\" on the webpage. This is needed because that \"division\" or block will contrain the Dash graphic, and we can create multiple Divisions for multiple Dashboards on the same webpage html.H1 - gives a header to the webpage html.Div - this nested Div creates another block within which is the Dashboard graphic dcc.Graph - specifies the type of graph that will be used. Depending on the graph, the data input will vary layout - Can specify the title of the plot. Arguments are listed in Plotly documentation We finally run the server using app.run_server . The server is required to keep running to access the webpage with the dashboard","title":"Sample barplot"},{"location":"dash/line charts/","text":"Line Charts Essentially data points called markers joined by line segments Create x and y values data = [go.Scatter(x=<insert list of values>,y=<insert list of values>,mode = \"lines\",name=\"mylines\") Define layout layout = go.Layout(title = \" \" Execute figure fig = go.Figure(data = data, layout = layout) pyo.plot(fig)","title":"Line charts"},{"location":"dash/line charts/#line-charts","text":"Essentially data points called markers joined by line segments","title":"Line Charts"},{"location":"dash/line charts/#create-x-and-y-values","text":"data = [go.Scatter(x=<insert list of values>,y=<insert list of values>,mode = \"lines\",name=\"mylines\")","title":"Create x and y values"},{"location":"dash/line charts/#define-layout","text":"layout = go.Layout(title = \" \"","title":"Define layout"},{"location":"dash/line charts/#execute-figure","text":"fig = go.Figure(data = data, layout = layout) pyo.plot(fig)","title":"Execute figure"},{"location":"dash/numpy-basics/","text":"Numpy Numpy is a package used to conduct data analysis in Python. For Dash, numpy arrays are useful as input for Plotly and Dash objects (Dash is built by Plotly) First install pandas and numpy pip install numpy Import numpy import numpy as np Arrays in Numpy Convert list to array mylist = [1,2,3,4] arr = np.array(mylist) Differences with Lists + in arrays do element-wise addition, versus concatenation in lists in arrays do element-wise multiplication, versus duplication in lists ** in arrays do element-wise squaring; this does not work in lists Math operations np.sum() gives sum of elements in array np.dot() gives dot product of two arrays np.sqrt() gives square root of an array np.mean() gives mean of array np.var() gives variance of array","title":"Numpy Basics"},{"location":"dash/numpy-basics/#numpy","text":"Numpy is a package used to conduct data analysis in Python. For Dash, numpy arrays are useful as input for Plotly and Dash objects (Dash is built by Plotly)","title":"Numpy"},{"location":"dash/numpy-basics/#first-install-pandas-and-numpy","text":"pip install numpy","title":"First install pandas and numpy"},{"location":"dash/numpy-basics/#import-numpy","text":"import numpy as np","title":"Import numpy"},{"location":"dash/numpy-basics/#arrays-in-numpy","text":"Convert list to array mylist = [1,2,3,4] arr = np.array(mylist)","title":"Arrays in Numpy"},{"location":"dash/numpy-basics/#differences-with-lists","text":"+ in arrays do element-wise addition, versus concatenation in lists in arrays do element-wise multiplication, versus duplication in lists ** in arrays do element-wise squaring; this does not work in lists","title":"Differences with Lists"},{"location":"dash/numpy-basics/#math-operations","text":"np.sum() gives sum of elements in array np.dot() gives dot product of two arrays np.sqrt() gives square root of an array np.mean() gives mean of array np.var() gives variance of array","title":"Math operations"},{"location":"dash/pandas-basics/","text":"Why Pandas Pandas is essential for data analysis. It allows us to work with data.frames which makes it easy for us to use as input for machine learning models and for graphics packages. Dash also works well with data.frames, and hence this tutorial is included. Install pandas pip install pandas Import pandas import pandas as pd Read csv as data.frame df = pd.read_csv(\"salaries.csv\") CSV stand for comma-separated values. Most modern data is formatted into csv files for easier analysis with pandas data.frames. Converting Numpy array to data.frame Matrix of 5 rows and 10 columns mat = np.arange(0,50).reshape(5,10) Converting to pandas data.frame df = pd.DataFrame(data = mat) Data.frame format Data.frames have 2 attributes: - rows or indices - columns Row indices are useful for keeping track of observations and for subsetting rows of a data.frame with loc Finding column names df.columns columns is an attribute, not a method, so there are no parentheses. Renaming columns df.columns = [\"f1\",\"f2\",\"f3\",\"f4\",\"label\"] Referencing columns Columns in dataa.frames are referenced in square brackets using double quotes: df[\"<column name>\"] A single column that is referenced returns a Series object. df[\"col 1\"] - returns series Referencing columns to return data.frame To return a data.frame, place the reference inside a list: df[[\"<column name>\"]] - returns data.frame You can also call multiple columns by name by placing them inside lists Referencing rows and columns with loc loc is used to return certain rows and columns of a data.frame df.loc[\"<row>\", \"<column>\"] loc is useful if you know the \"index\" or name of the row (and column) that you want to subset. However, it is easier to use iloc if you want to reference rows and columns by integers Referencing rows and columns with iloc If you want to reference rows and columns by their position, use iloc df.iloc[<rownumber>,<colnumber>] To reference multiple rows and multiple columns, put the rows and/columns into a list","title":"Pandas Basics"},{"location":"dash/pandas-basics/#why-pandas","text":"Pandas is essential for data analysis. It allows us to work with data.frames which makes it easy for us to use as input for machine learning models and for graphics packages. Dash also works well with data.frames, and hence this tutorial is included.","title":"Why Pandas"},{"location":"dash/pandas-basics/#install-pandas","text":"pip install pandas","title":"Install pandas"},{"location":"dash/pandas-basics/#import-pandas","text":"import pandas as pd","title":"Import pandas"},{"location":"dash/pandas-basics/#read-csv-as-dataframe","text":"df = pd.read_csv(\"salaries.csv\") CSV stand for comma-separated values. Most modern data is formatted into csv files for easier analysis with pandas data.frames.","title":"Read csv as data.frame"},{"location":"dash/pandas-basics/#converting-numpy-array-to-dataframe","text":"Matrix of 5 rows and 10 columns mat = np.arange(0,50).reshape(5,10) Converting to pandas data.frame df = pd.DataFrame(data = mat)","title":"Converting Numpy array to data.frame"},{"location":"dash/pandas-basics/#dataframe-format","text":"Data.frames have 2 attributes: - rows or indices - columns Row indices are useful for keeping track of observations and for subsetting rows of a data.frame with loc","title":"Data.frame format"},{"location":"dash/pandas-basics/#finding-column-names","text":"df.columns columns is an attribute, not a method, so there are no parentheses.","title":"Finding column names"},{"location":"dash/pandas-basics/#renaming-columns","text":"df.columns = [\"f1\",\"f2\",\"f3\",\"f4\",\"label\"]","title":"Renaming columns"},{"location":"dash/pandas-basics/#referencing-columns","text":"Columns in dataa.frames are referenced in square brackets using double quotes: df[\"<column name>\"] A single column that is referenced returns a Series object. df[\"col 1\"] - returns series","title":"Referencing columns"},{"location":"dash/pandas-basics/#referencing-columns-to-return-dataframe","text":"To return a data.frame, place the reference inside a list: df[[\"<column name>\"]] - returns data.frame You can also call multiple columns by name by placing them inside lists","title":"Referencing columns to return data.frame"},{"location":"dash/pandas-basics/#referencing-rows-and-columns-with-loc","text":"loc is used to return certain rows and columns of a data.frame df.loc[\"<row>\", \"<column>\"] loc is useful if you know the \"index\" or name of the row (and column) that you want to subset. However, it is easier to use iloc if you want to reference rows and columns by integers","title":"Referencing rows and columns with loc"},{"location":"dash/pandas-basics/#referencing-rows-and-columns-with-iloc","text":"If you want to reference rows and columns by their position, use iloc df.iloc[<rownumber>,<colnumber>] To reference multiple rows and multiple columns, put the rows and/columns into a list","title":"Referencing rows and columns with iloc"},{"location":"dash/plotly-barplots/","text":"Barplots in Plotly Create data set data = [go.Bar(x=<insert list/array or df col>,y=<insert list/array or df col>)] x is an array or column of factors y is corresponding array or column of total count of something Define layout layout=go.Layout(title=\"<insert graph title>\", ...) Store figure in fig and execute fig = go.Figure(data,layout) pyo.plot(fig)","title":"Plotly Barplots"},{"location":"dash/plotly-barplots/#barplots-in-plotly","text":"","title":"Barplots in Plotly"},{"location":"dash/plotly-barplots/#create-data-set","text":"data = [go.Bar(x=<insert list/array or df col>,y=<insert list/array or df col>)] x is an array or column of factors y is corresponding array or column of total count of something","title":"Create data set"},{"location":"dash/plotly-barplots/#define-layout","text":"layout=go.Layout(title=\"<insert graph title>\", ...)","title":"Define layout"},{"location":"dash/plotly-barplots/#store-figure-in-fig-and-execute","text":"fig = go.Figure(data,layout) pyo.plot(fig)","title":"Store figure in fig and execute"},{"location":"dash/plotly-basics/","text":"Install plotly Basic plotly gives us an idea of Dash syntax and documentation. Dash syntax for its graphics are built on top of plotly. Plotly images are saved as html files in the computer. pip install plotly==4.2.1 Import plotly import plotly.offline as pyo import plotly.graph_objs as go Scatter plots Data must first be in a list Setup data data = [go.Scatter(x= <list of values for x-axis>, y =<list of values for y-axis>, mode = 'markers', marker = dict(size = <numeric size>, color = \"<insert color or rgb>\", symbol = \"<type of scatterplot symbol>\", line = dict(<dictionary specifying with of line>) ))] ``` <br> <br> ### Define Layout layout = go.Layout(title = \"<insert plot title\", xaxis = dict(title = \"MY X AXIS\" , yaxis = dict(title = \"MY Y AXIS\"), hovermode = \"closest\") ``` Save HTML file pyo.plot(data, filename = \"<insert name>.html\") Execute fig = go.Figure(data=data,layout=layout) pyo.plot(fig,filename=\"<filename>.html\")","title":"Plotly Basics"},{"location":"dash/plotly-basics/#install-plotly","text":"Basic plotly gives us an idea of Dash syntax and documentation. Dash syntax for its graphics are built on top of plotly. Plotly images are saved as html files in the computer. pip install plotly==4.2.1","title":"Install plotly"},{"location":"dash/plotly-basics/#import-plotly","text":"import plotly.offline as pyo import plotly.graph_objs as go","title":"Import plotly"},{"location":"dash/plotly-basics/#scatter-plots","text":"Data must first be in a list","title":"Scatter plots"},{"location":"dash/plotly-basics/#setup-data","text":"data = [go.Scatter(x= <list of values for x-axis>, y =<list of values for y-axis>, mode = 'markers', marker = dict(size = <numeric size>, color = \"<insert color or rgb>\", symbol = \"<type of scatterplot symbol>\", line = dict(<dictionary specifying with of line>) ))] ``` <br> <br> ### Define Layout layout = go.Layout(title = \"<insert plot title\", xaxis = dict(title = \"MY X AXIS\" , yaxis = dict(title = \"MY Y AXIS\"), hovermode = \"closest\") ```","title":"Setup data"},{"location":"dash/plotly-basics/#save-html-file","text":"pyo.plot(data, filename = \"<insert name>.html\")","title":"Save HTML file"},{"location":"dash/plotly-basics/#execute","text":"fig = go.Figure(data=data,layout=layout) pyo.plot(fig,filename=\"<filename>.html\")","title":"Execute"},{"location":"flask/dynamic-routing/","text":"Dynamic Routing Route to different page depending on situation, such as in when different users log in to different accounts. However, steps to create and initialize Flask app remain the same. Create app.route @app.route('/some_page/<name>') def other_page(name): #essentially we're just returning user and formatting the name into the user return 'User: {}'.format(name) is an input, in this case for example the username. Flask will route to a different page depending on username input. Run server if __name__ == \"__main__\": app.run() Must add /some_page/ to the end of the URL, where name can be anything","title":"Dynamic Routing"},{"location":"flask/dynamic-routing/#dynamic-routing","text":"Route to different page depending on situation, such as in when different users log in to different accounts. However, steps to create and initialize Flask app remain the same.","title":"Dynamic Routing"},{"location":"flask/dynamic-routing/#create-approute","text":"@app.route('/some_page/<name>') def other_page(name): #essentially we're just returning user and formatting the name into the user return 'User: {}'.format(name) is an input, in this case for example the username. Flask will route to a different page depending on username input.","title":"Create app.route"},{"location":"flask/dynamic-routing/#run-server","text":"if __name__ == \"__main__\": app.run() Must add /some_page/ to the end of the URL, where name can be anything","title":"Run server"},{"location":"flask/first-website/","text":"Flask Beginner Tutorial Basic Flask concepts and routing tutorial Flask Basics How to create a very simple first webpage First install Flask pip install flask Import Flask from flask import flask Create instance of Flask app = Flask(__name__) Route to homepage @app.route('/') Define function to display content def index(): return '<h1>Hello Puppy!</h1>' Run server if __name__ == '__main__': app.run() You will get an output that says: Running on http://127.0.0.1:5000/ Click on link to see your first webpage","title":"Creating First Website"},{"location":"flask/first-website/#flask-beginner-tutorial","text":"Basic Flask concepts and routing tutorial","title":"Flask Beginner Tutorial"},{"location":"flask/first-website/#flask-basics","text":"How to create a very simple first webpage","title":"Flask Basics"},{"location":"flask/first-website/#first-install-flask","text":"pip install flask","title":"First install Flask"},{"location":"flask/first-website/#import-flask","text":"from flask import flask","title":"Import Flask"},{"location":"flask/first-website/#create-instance-of-flask","text":"app = Flask(__name__)","title":"Create instance of Flask"},{"location":"flask/first-website/#route-to-homepage","text":"@app.route('/')","title":"Route to homepage"},{"location":"flask/first-website/#define-function-to-display-content","text":"def index(): return '<h1>Hello Puppy!</h1>'","title":"Define function to display content"},{"location":"flask/first-website/#run-server","text":"if __name__ == '__main__': app.run() You will get an output that says: Running on http://127.0.0.1:5000/ Click on link to see your first webpage","title":"Run server"},{"location":"flask/flask-concepts/","text":"How Flask works When we open a browser we see a few things: Front-End - HTML displays the page elements like the actual text on the website - CSS styles the elemtns liek change font or sizeof the text - Bootstrap provides some automatic styling through CSS and Javascript Every website will perform some main ops: - Accept info from user - Retrieve info from databse - Create/Update/Delee info in the database - Display information back to the user To connect the front-end stuff to web database, we need a web framework. Web framework's job is to accept user information from website and connect to back-end database and report something relevant that can be stored in the db and communicate it to the front-end so user can see it. Flask is a web framework. Allows to connect Python code to the web. Flask does has reputation for being not scalable. Accepting user information Could be something like accepting query into Google search - instance of user filling out info. WTForms is a library that works well with flask Communicate with database and retrieve information. In this case its SQLite. SQLite can scale to quite a large website. SQLAlchemy allows us to write Python code instead of SQL queries Flask is like connector between front-end and back-end info that is stored Jinja templates grab info from Python and Flask ad send info back as HTML Flask renders HTML templates Virtual Environment Launched web app and want to use external python library, but the library gets updated. We can set up virtual environment to help manage dependencies.","title":"Intro to Flask"},{"location":"flask/flask-concepts/#how-flask-works","text":"When we open a browser we see a few things: Front-End - HTML displays the page elements like the actual text on the website - CSS styles the elemtns liek change font or sizeof the text - Bootstrap provides some automatic styling through CSS and Javascript Every website will perform some main ops: - Accept info from user - Retrieve info from databse - Create/Update/Delee info in the database - Display information back to the user To connect the front-end stuff to web database, we need a web framework. Web framework's job is to accept user information from website and connect to back-end database and report something relevant that can be stored in the db and communicate it to the front-end so user can see it. Flask is a web framework. Allows to connect Python code to the web. Flask does has reputation for being not scalable.","title":"How Flask works"},{"location":"flask/flask-concepts/#accepting-user-information","text":"Could be something like accepting query into Google search - instance of user filling out info. WTForms is a library that works well with flask Communicate with database and retrieve information. In this case its SQLite. SQLite can scale to quite a large website. SQLAlchemy allows us to write Python code instead of SQL queries Flask is like connector between front-end and back-end info that is stored Jinja templates grab info from Python and Flask ad send info back as HTML Flask renders HTML templates","title":"Accepting user information"},{"location":"flask/flask-concepts/#virtual-environment","text":"Launched web app and want to use external python library, but the library gets updated. We can set up virtual environment to help manage dependencies.","title":"Virtual Environment"},{"location":"icd-11/ICD-11-Dash/","text":"Creating network tree from 26 json files ICD 11 data consists of 26 root nodes, each having its own subtree. The data for each subtree/root was downloaded using a recursive algorithm deployed by Dibakar Sigdel. The network graph database was made created using NetworkX, with the following code trees = [] for data in N: G = nx.Graph() for item in data: item_id = item['id'] G.add_node(item_id,\\ title=item['title'],\\ defn = item['defn']) childs = item['childs'] if childs!= 'Key Not found': for c_id in childs: G.add_edge(item_id,c_id, object = 'child') trees.append(G) The JSON files were imported and read into a list, and another list was created which stored the nodes and edges of all the nodes in the 26 trees. Properties of nodes Item id: ID of the node Title: Name of the node Defn: Description of the node Child: Children of the node (helps in building edges that specify relationship Tidying data into pandas.dataframe <<<<<<< HEAD The reason we want to do this is because Dash works well with pandas data.frames. lists = [] #list storing every single root with its subtree for G in trees: root = list(G.nodes())[0] #stores the root tree node2depth = [] #for loop to iterate through every node in the each subtree for node in G.nodes(): depth = nx.shortest_path_length(G, root, node) #print(node,\"|\",depth) node2depth.append({\"node\":node,\"depth\":depth}) DF = pd.DataFrame(node2depth) #stores node id and corresponding depth level DF = DF.set_index(\"depth\") lists.append(DF.groupby(\"depth\").count()) Transform data.frame into tidy format (observations in rows, variables in columns) df = pd.concat(lists, axis=1) df = df.fillna(0) df = df.transpose() df.index = titles df = df.astype(int) df2 = df.assign(total_nodes = lambda x: df.sum(axis =1)) ======= The reason we want to do this is because Dash works well with pandas data.frames fdebf356440937f88cd478d30c950f880a9470e1","title":"ICD 11 Data Entry"},{"location":"icd-11/ICD-11-Dash/#creating-network-tree-from-26-json-files","text":"ICD 11 data consists of 26 root nodes, each having its own subtree. The data for each subtree/root was downloaded using a recursive algorithm deployed by Dibakar Sigdel. The network graph database was made created using NetworkX, with the following code trees = [] for data in N: G = nx.Graph() for item in data: item_id = item['id'] G.add_node(item_id,\\ title=item['title'],\\ defn = item['defn']) childs = item['childs'] if childs!= 'Key Not found': for c_id in childs: G.add_edge(item_id,c_id, object = 'child') trees.append(G) The JSON files were imported and read into a list, and another list was created which stored the nodes and edges of all the nodes in the 26 trees.","title":"Creating network tree from 26 json files"},{"location":"icd-11/ICD-11-Dash/#properties-of-nodes","text":"Item id: ID of the node Title: Name of the node Defn: Description of the node Child: Children of the node (helps in building edges that specify relationship","title":"Properties of nodes"},{"location":"icd-11/ICD-11-Dash/#tidying-data-into-pandasdataframe","text":"<<<<<<< HEAD The reason we want to do this is because Dash works well with pandas data.frames. lists = [] #list storing every single root with its subtree for G in trees: root = list(G.nodes())[0] #stores the root tree node2depth = [] #for loop to iterate through every node in the each subtree for node in G.nodes(): depth = nx.shortest_path_length(G, root, node) #print(node,\"|\",depth) node2depth.append({\"node\":node,\"depth\":depth}) DF = pd.DataFrame(node2depth) #stores node id and corresponding depth level DF = DF.set_index(\"depth\") lists.append(DF.groupby(\"depth\").count())","title":"Tidying data into pandas.dataframe"},{"location":"icd-11/ICD-11-Dash/#transform-dataframe-into-tidy-format-observations-in-rows-variables-in-columns","text":"df = pd.concat(lists, axis=1) df = df.fillna(0) df = df.transpose() df.index = titles df = df.astype(int) df2 = df.assign(total_nodes = lambda x: df.sum(axis =1)) ======= The reason we want to do this is because Dash works well with pandas data.frames fdebf356440937f88cd478d30c950f880a9470e1","title":"Transform data.frame into tidy format (observations in rows, variables in columns)"},{"location":"icd-11/ICD-11-Visualizations/","text":"ICD 11 Visualizations were created using Dash and data cleaned and obtained from ICD 11 Website and API. A data.frame of each root node with number of nodes per level was created and imported. Importing libraries import pandas as pd import numpy as np import dash import dash_core_components as dcc import dash_html_components as html from dash.dependencies import Input, Output import plotly.graph_objs as go import dash_bio as dashbio Import csv as data.frame pd.read_csv(\"withoutsum.csv\") Interactive barplot showing nodes per level for each root Set up instance of Dash app = dash.Dash() Specify dashboard layout Once an instance of Dash is created, the layout of the dashboard must be specified. html.Div creates a division or container on the web page within which the dashboard will be fit. Inside html.Div(), a list is accepted and components of the dashboard are specified. In this case, we have a dropdown from which a user can choose which root node they want to look and look at the distribution of nodes in each level of that root node. A pointer to the graph of the dashboard also needs to be specified. app.layout = html.Div([ dcc.Dropdown(id=\"disease-type\", # options = [{\"label\":disease, \"value\":disease} for disease in df[cols[0]]], #dropdown list containing each root node value = df[cols[0]].iloc[0] ), dcc.Graph(id=\"graphics\") ]) Specify callback @app.callback is a decorator that specifies which are the inputs and outputs of the graph. The decorator points to the elements specified in the dashboard layout object. @app.callback( Output(\"graphics\",\"figure\"), #connects to the graphics id in [Input(\"disease-type\",\"value\")]) Update graph function Since our dashboard is an interactive graphic that updates depending on user input, we need to create a function that describes this behavior. The function below matches the user input with the data in the data.frame, and returns the barplot with detailed layout of the data, title, and x and y axes. def update_graph(selected_disease): filtered_df = df[df[cols[0]] == selected_disease] nodes = filtered_df.loc[:,\"1\":\"12\"].values.tolist() nodes = nodes[0] return { \"data\": [ {\"x\":list(cols)[2:14],\"y\":nodes,\"type\":\"bar\"}, ], \"layout\": go.Layout(title = \"Nodes Per Level\", xaxis = {\"title\":\"Levels\"}, yaxis = {\"title\":\"Nodes\"} ) } Run server Finally, we launch the server on which the dashboard is hosted with the following command: if __name__ == \"__main__\": app.run_server() Snapshot of Graphic","title":"ICD 11 Dashboards"},{"location":"icd-11/ICD-11-Visualizations/#importing-libraries","text":"import pandas as pd import numpy as np import dash import dash_core_components as dcc import dash_html_components as html from dash.dependencies import Input, Output import plotly.graph_objs as go import dash_bio as dashbio","title":"Importing libraries"},{"location":"icd-11/ICD-11-Visualizations/#import-csv-as-dataframe","text":"pd.read_csv(\"withoutsum.csv\")","title":"Import csv as data.frame"},{"location":"icd-11/ICD-11-Visualizations/#interactive-barplot-showing-nodes-per-level-for-each-root","text":"","title":"Interactive barplot showing nodes per level for each root"},{"location":"icd-11/ICD-11-Visualizations/#set-up-instance-of-dash","text":"app = dash.Dash()","title":"Set up instance of Dash"},{"location":"icd-11/ICD-11-Visualizations/#specify-dashboard-layout","text":"Once an instance of Dash is created, the layout of the dashboard must be specified. html.Div creates a division or container on the web page within which the dashboard will be fit. Inside html.Div(), a list is accepted and components of the dashboard are specified. In this case, we have a dropdown from which a user can choose which root node they want to look and look at the distribution of nodes in each level of that root node. A pointer to the graph of the dashboard also needs to be specified. app.layout = html.Div([ dcc.Dropdown(id=\"disease-type\", # options = [{\"label\":disease, \"value\":disease} for disease in df[cols[0]]], #dropdown list containing each root node value = df[cols[0]].iloc[0] ), dcc.Graph(id=\"graphics\") ])","title":"Specify dashboard layout"},{"location":"icd-11/ICD-11-Visualizations/#specify-callback","text":"@app.callback is a decorator that specifies which are the inputs and outputs of the graph. The decorator points to the elements specified in the dashboard layout object. @app.callback( Output(\"graphics\",\"figure\"), #connects to the graphics id in [Input(\"disease-type\",\"value\")])","title":"Specify callback"},{"location":"icd-11/ICD-11-Visualizations/#update-graph-function","text":"Since our dashboard is an interactive graphic that updates depending on user input, we need to create a function that describes this behavior. The function below matches the user input with the data in the data.frame, and returns the barplot with detailed layout of the data, title, and x and y axes. def update_graph(selected_disease): filtered_df = df[df[cols[0]] == selected_disease] nodes = filtered_df.loc[:,\"1\":\"12\"].values.tolist() nodes = nodes[0] return { \"data\": [ {\"x\":list(cols)[2:14],\"y\":nodes,\"type\":\"bar\"}, ], \"layout\": go.Layout(title = \"Nodes Per Level\", xaxis = {\"title\":\"Levels\"}, yaxis = {\"title\":\"Nodes\"} ) }","title":"Update graph function"},{"location":"icd-11/ICD-11-Visualizations/#run-server","text":"Finally, we launch the server on which the dashboard is hosted with the following command: if __name__ == \"__main__\": app.run_server()","title":"Run server"},{"location":"icd-11/ICD-11-Visualizations/#snapshot-of-graphic","text":"","title":"Snapshot of Graphic"},{"location":"neo4j/icd11-neo4j/","text":"Neo4j with ICD 11 Data ICD 11 MMS data was transformed into a network graph in Neo4j using Neo4j's Python Bolt Driver. A Neo4j driver enables a developer to run Cypher queries in Python. These queries can be consumed as BoltStatementResults, which is an object returned by Neo4j in Python. Install Neo4j pip install neo4j Import Neo4j from neo4j import GraphDatabase Load JSON file with open(\"MMS.json\",\"r\") as mms: mms_data = json.load(mms) Initialize Neo4j Driver To initialize driver, Neo4j must be open in the application and local server set up in Neo4j. The driver argument takes the following arguments: - uri: identifies graph database and how to connect it - auth: authentication that requires the username, password driver = GraphDatabase.driver(uri = \"bolt://localhost:11008\", auth = (\"neo4j\",\"pythondriver\")) Populate MMS data in Neo4j A single MMS","title":"Neo4j with ICD 11 Data"},{"location":"neo4j/icd11-neo4j/#neo4j-with-icd-11-data","text":"ICD 11 MMS data was transformed into a network graph in Neo4j using Neo4j's Python Bolt Driver. A Neo4j driver enables a developer to run Cypher queries in Python. These queries can be consumed as BoltStatementResults, which is an object returned by Neo4j in Python.","title":"Neo4j with ICD 11 Data"},{"location":"neo4j/icd11-neo4j/#install-neo4j","text":"pip install neo4j","title":"Install Neo4j"},{"location":"neo4j/icd11-neo4j/#import-neo4j","text":"from neo4j import GraphDatabase","title":"Import Neo4j"},{"location":"neo4j/icd11-neo4j/#load-json-file","text":"with open(\"MMS.json\",\"r\") as mms: mms_data = json.load(mms)","title":"Load JSON file"},{"location":"neo4j/icd11-neo4j/#initialize-neo4j-driver","text":"To initialize driver, Neo4j must be open in the application and local server set up in Neo4j. The driver argument takes the following arguments: - uri: identifies graph database and how to connect it - auth: authentication that requires the username, password driver = GraphDatabase.driver(uri = \"bolt://localhost:11008\", auth = (\"neo4j\",\"pythondriver\"))","title":"Initialize Neo4j Driver"},{"location":"neo4j/icd11-neo4j/#populate-mms-data-in-neo4j","text":"A single MMS","title":"Populate MMS data in Neo4j"},{"location":"neo4j/neo4j-learning/","text":"Neo4j Neo4j is a graph database platform that simplifies operations and analysis on network graphs. It is designed for fast management of nodes and relationships and is significantly faster than performing JOINS on tables. Neo4j Cypher Cypher is Neo4j's query language. It is built for working with graph data and uses patterns to match and describe graph data. Example of a Neo4j query: Node syntax in Cypher () represents an anonymous node. If we want to refer to the node elsewhere, we add a varriable, like (matrix). () - anonymous node (matrix) - variable added to node. This variable can be referenced later in the query (:Movie) - label :Movie declares the node's type (matrix:Movie) - variable name matrix with label Movie (matrix:Movie {title: \"The Matrix\"}) - variable matrix of type Movie with the property title having value 'The Matrix' (matrix:Movie {title: \"The Matrix\", released: 1997}) Variables are restricted to single statement i.e they may have different or no meaning in another statement Pattern Syntax Example: (:Person) - [:LIVES_IN]->(:CITY)-[:PART_OF]->(:Country) This statement finds a Person (label) who \"Lives in\" (relationship) in a \"City\" (label) which is \"Part Of\" (relationship) a \"country\" (label) Pattern Syntax with variables Using a variable is useful if one wants to refer to that variable later on in a query. IF we are matching a label, we may just specify any variable name before the colon as shown below: MERGE (a:Person {name:\"Ann\"}) CREATE (a)-[\"HAS_PET]->(:Dog{name:\"Sam\"}) The above query Creates a relationship with the Dog whose name is Sam. The person is stored as a and a is referred to when creating the node and relationship with Ann's pet.","title":"Intro to Neo4j"},{"location":"neo4j/neo4j-learning/#neo4j","text":"Neo4j is a graph database platform that simplifies operations and analysis on network graphs. It is designed for fast management of nodes and relationships and is significantly faster than performing JOINS on tables.","title":"Neo4j"},{"location":"neo4j/neo4j-learning/#neo4j-cypher","text":"Cypher is Neo4j's query language. It is built for working with graph data and uses patterns to match and describe graph data. Example of a Neo4j query:","title":"Neo4j Cypher"},{"location":"neo4j/neo4j-learning/#node-syntax-in-cypher","text":"() represents an anonymous node. If we want to refer to the node elsewhere, we add a varriable, like (matrix). () - anonymous node (matrix) - variable added to node. This variable can be referenced later in the query (:Movie) - label :Movie declares the node's type (matrix:Movie) - variable name matrix with label Movie (matrix:Movie {title: \"The Matrix\"}) - variable matrix of type Movie with the property title having value 'The Matrix' (matrix:Movie {title: \"The Matrix\", released: 1997}) Variables are restricted to single statement i.e they may have different or no meaning in another statement","title":"Node syntax in Cypher"},{"location":"neo4j/neo4j-learning/#pattern-syntax","text":"Example: (:Person) - [:LIVES_IN]->(:CITY)-[:PART_OF]->(:Country) This statement finds a Person (label) who \"Lives in\" (relationship) in a \"City\" (label) which is \"Part Of\" (relationship) a \"country\" (label)","title":"Pattern Syntax"},{"location":"neo4j/neo4j-learning/#pattern-syntax-with-variables","text":"Using a variable is useful if one wants to refer to that variable later on in a query. IF we are matching a label, we may just specify any variable name before the colon as shown below: MERGE (a:Person {name:\"Ann\"}) CREATE (a)-[\"HAS_PET]->(:Dog{name:\"Sam\"}) The above query Creates a relationship with the Dog whose name is Sam. The person is stored as a and a is referred to when creating the node and relationship with Ann's pet.","title":"Pattern Syntax with variables"}]}